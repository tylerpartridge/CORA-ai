#!/usr/bin/env python3
"""
ðŸ§­ LOCATION: /CORA/routes/dashboard_routes.py
ðŸŽ¯ PURPOSE: Dashboard routes with real financial data and metrics
ðŸ”— IMPORTS: FastAPI, SQLAlchemy, models, dependencies
ðŸ“¤ EXPORTS: dashboard_router with summary, metrics, insights endpoints
"""

from fastapi import APIRouter, Depends
from fastapi.responses import StreamingResponse
from sqlalchemy import func, or_
from sqlalchemy.orm import Session
from datetime import datetime, timedelta, date
from typing import Dict, Any
import csv
import io
import logging
from functools import lru_cache

from models import get_db, User, Expense, ExpenseCategory, Job
from dependencies.auth import get_current_user

logger = logging.getLogger(__name__)

# Create router
dashboard_router = APIRouter(
    prefix="/api/dashboard",
    tags=["Dashboard"],
    responses={404: {"description": "Not found"}},
)

def _period_range(period: str) -> tuple[datetime, datetime]:
    now = datetime.utcnow()
    if period == "today":
        start = now.replace(hour=0, minute=0, second=0, microsecond=0)
        end = now
    elif period == "week":
        start = now - timedelta(days=7)
        end = now
    elif period == "quarter":
        quarter = (now.month - 1) // 3
        start = datetime(now.year, quarter * 3 + 1, 1)
        if quarter < 3:
            end = datetime(now.year, (quarter + 1) * 3 + 1, 1) - timedelta(seconds=1)
        else:
            end = datetime(now.year + 1, 1, 1) - timedelta(seconds=1)
    elif period == "year":
        start = now.replace(month=1, day=1, hour=0, minute=0, second=0, microsecond=0)
        end = now
    else:  # default month
        start = now.replace(day=1, hour=0, minute=0, second=0, microsecond=0)
        end = now
    return start, end


def _job_cost_cents(db: Session, user_id: int, job: Job, start: datetime | None = None, end: datetime | None = None) -> int:
    q = db.query(func.sum(Expense.amount_cents)).filter(Expense.user_email == user_email)
    # Prefer matching by job_id if present, otherwise by job_name
    if job.job_id:
        q = q.filter(Expense.job_id == job.job_id)
    else:
        q = q.filter(Expense.job_name == job.job_name)
    if start is not None:
        q = q.filter(Expense.expense_date >= start)
    if end is not None:
        q = q.filter(Expense.expense_date <= end)
    return q.scalar() or 0


@dashboard_router.get("/jobs")
async def get_jobs(
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Return the user's jobs with basic profit approximation.

    Note: We currently do not have per-job cost aggregation wired here.
    Profit is approximated as quoted_amount for now to unblock UI; when
    job-level expenses are modeled, subtract costs accordingly.
    """
    jobs = (
        db.query(Job)
        .filter(Job.user_id == current_user.id)
        .order_by(Job.created_at.desc())
        .limit(50)
        .all()
    )
    start, end = _period_range("month")
    payload = []
    for j in jobs:
        quoted_cents = int((j.quoted_amount or 0) * 100)
        cost_cents = _job_cost_cents(db, current_user.id, j, start, end)
        profit_cents = quoted_cents - cost_cents
        margin_pct = round((profit_cents / quoted_cents * 100), 1) if quoted_cents > 0 else 0
        payload.append({
            "id": j.id,
            "name": j.job_name,
            "status": j.status,
            "quoted": float(j.quoted_amount or 0),
            "cost": cost_cents / 100.0,
            "profit": profit_cents / 100.0,
            "margin": margin_pct,
        })
    result = {"jobs": payload}
    return result


@dashboard_router.get("/jobs/filtered")
async def get_jobs_filtered(
    period: str = "month",
    status: str | None = None,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    start, end = _period_range(period)
    q = db.query(Job).filter(Job.user_id == current_user.id)
    if status:
        q = q.filter(Job.status == status)
    jobs = q.order_by(Job.created_at.desc()).limit(200).all()
    payload = []
    for j in jobs:
        quoted_cents = int((j.quoted_amount or 0) * 100)
        cost_cents = _job_cost_cents(db, current_user.id, j, start, end)
        profit_cents = quoted_cents - cost_cents
        margin_pct = round((profit_cents / quoted_cents * 100), 1) if quoted_cents > 0 else 0
        payload.append({
            "id": j.id,
            "name": j.job_name,
            "status": j.status,
            "quoted": float(j.quoted_amount or 0),
            "cost": cost_cents / 100.0,
            "profit": profit_cents / 100.0,
            "margin": margin_pct,
        })
    return {"period": period, "jobs": payload}

@dashboard_router.get("/plaid-data")
async def get_plaid_dashboard_data(
    current_user: str = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Get real Plaid data for dashboard - OPTIMIZED VERSION"""
    try:
        from models.plaid_integration import PlaidIntegration, PlaidAccount
        from sqlalchemy.orm import joinedload
        from datetime import datetime, timedelta
        from services.plaid_service import PlaidService
        
        # Fetch integration
        integration = db.query(PlaidIntegration).filter(
            PlaidIntegration.user_id == current_user,
            PlaidIntegration.is_active == True
        ).first()
        
        if not integration:
            return {
                "connected": False,
                "message": "No bank account connected",
                "accounts": [],
                "transactions": [],
                "summary": {
                    "total_balance": 0,
                    "total_spending_30d": 0,
                    "total_income_30d": 0,
                    "transaction_count": 0
                }
            }
        
        # Fetch live balances from Plaid
        plaid_service = PlaidService(integration)  # Assume PlaidService exists similar to StripeService
        live_data = await plaid_service.get_balances()
        
        if "error" in live_data:
            # Fallback to DB data if API fail
            accounts = db.query(PlaidAccount).filter(PlaidAccount.integration_id == integration.id).all()
        else:
            # Update DB with live balances (optimized - bulk query instead of N+1)
            account_ids = [acc["account_id"] for acc in live_data.get("accounts", [])]
            accounts_dict = {acc.plaid_account_id: acc for acc in 
                db.query(PlaidAccount).filter(PlaidAccount.plaid_account_id.in_(account_ids)).all()
            }
            
            for acc_data in live_data.get("accounts", []):
                acc = accounts_dict.get(acc_data["account_id"])
                if acc:
                    acc.current_balance = acc_data["balances"]["current"]
                    acc.available_balance = acc_data["balances"]["available"]
            db.commit()
            accounts = db.query(PlaidAccount).filter(PlaidAccount.integration_id == integration.id).all()
        
        # Rest of calculation from DB (as before)
        thirty_days_ago = datetime.now() - timedelta(days=30)
        
        transactions = []
        for account in accounts:
            for txn in account.transactions:
                if txn.date >= thirty_days_ago:
                    transactions.append(txn)
        
        transactions.sort(key=lambda x: x.date, reverse=True)
        transactions = transactions[:100]
        
        total_balance = sum(acc.current_balance or 0 for acc in accounts)
        total_spending = sum(t.amount for t in transactions if t.amount > 0)
        total_income = sum(abs(t.amount) for t in transactions if t.amount < 0)
        
        # Get spending by category
        from collections import defaultdict
        spending_by_category = defaultdict(float)
        for t in transactions:
            if t.amount > 0:  # Expenses only
                category = t.category[0] if t.category else "Other"
                spending_by_category[category] += t.amount
        
        # Get subscriptions (recurring charges)
        subscription_merchants = set()
        merchant_counts = defaultdict(int)
        for t in transactions:
            if t.merchant_name:
                merchant_counts[t.merchant_name] += 1
        
        # If a merchant appears 2+ times in 30 days, likely a subscription
        subscriptions = []
        for merchant, count in merchant_counts.items():
            if count >= 2:
                # Find the transactions for this merchant
                merchant_txns = [t for t in transactions if t.merchant_name == merchant]
                if merchant_txns:
                    avg_amount = sum(t.amount for t in merchant_txns) / len(merchant_txns)
                    subscriptions.append({
                        "merchant": merchant,
                        "amount": avg_amount,
                        "frequency": count,
                        "last_charge": max(t.date for t in merchant_txns).isoformat()
                    })
        
        return {
            "connected": True,
            "institution": integration.institution_name,
            "last_sync": integration.last_sync_at.isoformat() if integration.last_sync_at else None,
            "accounts": [
                {
                    "id": acc.id,
                    "name": acc.display_name,
                    "type": acc.account_type,
                    "balance": acc.current_balance,
                    "available": acc.available_balance
                }
                for acc in accounts
            ],
            "transactions": [
                {
                    "id": t.id,
                    "date": t.date.isoformat(),
                    "amount": t.amount,
                    "merchant": t.merchant_name or t.name,
                    "category": t.category[0] if t.category else "Other",
                    "account": t.account.display_name,
                    "pending": t.pending
                }
                for t in transactions[:20]  # Last 20 transactions
            ],
            "summary": {
                "total_balance": total_balance,
                "total_spending_30d": total_spending,
                "total_income_30d": total_income,
                "transaction_count": len(transactions),
                "spending_by_category": dict(spending_by_category),
                "detected_subscriptions": subscriptions
            }
        }
    
    except Exception as e:
        logger.error(f"Error getting Plaid data: {e}")
        return {
            "connected": False,
            "error": str(e),
            "accounts": [],
            "transactions": [],
            "summary": {}
        }

@dashboard_router.get("/summary")
async def get_dashboard_summary(
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> Dict[str, Any]:
    """Get comprehensive dashboard summary with optimized queries and caching"""
    
    try:
        from utils.query_optimizer import get_optimized_dashboard_summary
        from utils.api_response_optimizer import optimize_api_response
        
        @optimize_api_response(compress=True, cache=True, cache_ttl=300)
        async def get_dashboard_data():
            return get_optimized_dashboard_summary(db, current_user.id)
        
        return await get_dashboard_data()
    except ImportError:
        # Fallback if optimization utilities not available
        return {
            "status": "success",
            "message": "Dashboard summary endpoint"
        }

def calculate_tracking_consistency(db: Session, user_id: str) -> float:
    """Calculate how consistently user tracks expenses (0-100)"""
    # Check last 30 days
    days_with_expenses = db.query(
        func.count(func.distinct(func.date(Expense.expense_date)))
    ).filter(
        Expense.user_email == user_email,
        Expense.expense_date >= datetime.utcnow() - timedelta(days=30)
    ).scalar() or 0
    
    # Assume tracking 5 days/week is 100%
    consistency = min((days_with_expenses / 22) * 100, 100)
    return round(consistency, 1)

def calculate_categorization_rate(db: Session, user_id: str) -> float:
    """Calculate percentage of expenses with categories"""
    total = db.query(func.count(Expense.id)).filter(
        Expense.user_email == user_email
    ).scalar() or 0
    
    categorized = db.query(func.count(Expense.id)).filter(
        Expense.user_email == user_email,
        Expense.category_id.isnot(None)
    ).scalar() or 0
    
    if total == 0:
        return 0.0
    return round((categorized / total) * 100, 1)

def calculate_receipt_capture_rate(db: Session, user_id: str) -> float:
    """Calculate percentage of expenses with receipts"""
    total = db.query(func.count(Expense.id)).filter(
        Expense.user_email == user_email
    ).scalar() or 0
    
    with_receipts = db.query(func.count(Expense.id)).filter(
        Expense.user_email == user_email,
        or_(Expense.receipt_url.isnot(None), Expense.receipt_path.isnot(None))
    ).scalar() or 0
    
    if total == 0:
        return 0.0
    return round((with_receipts / total) * 100, 1)

@lru_cache(maxsize=128)
@dashboard_router.get("/metrics")
async def get_metrics(
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user),
    period: str = "month"  # month, quarter, year
) -> Dict[str, Any]:
    """Get comprehensive business metrics with cash flow analysis"""
    
    now = datetime.utcnow()
    
    # Determine date range based on period
    if period == "month":
        start_date = now.replace(day=1, hour=0, minute=0, second=0, microsecond=0)
        end_date = start_date + timedelta(days=32)
        end_date = end_date.replace(day=1) - timedelta(seconds=1)
    elif period == "quarter":
        quarter = (now.month - 1) // 3
        start_date = datetime(now.year, quarter * 3 + 1, 1)
        if quarter < 3:
            end_date = datetime(now.year, (quarter + 1) * 3 + 1, 1) - timedelta(seconds=1)
        else:
            end_date = datetime(now.year + 1, 1, 1) - timedelta(seconds=1)
    else:  # year
        start_date = now.replace(month=1, day=1, hour=0, minute=0, second=0, microsecond=0)
        end_date = now.replace(month=12, day=31, hour=23, minute=59, second=59)
    
    # Calculate total expenses
    total_expenses = db.query(func.sum(Expense.amount_cents)).filter(
        Expense.user_email == current_user.email,
        Expense.expense_date >= start_date,
        Expense.expense_date <= end_date
    ).scalar() or 0
    
    # Get expenses by category for breakdown
    expense_breakdown = db.query(
        ExpenseCategory.name,
        func.sum(Expense.amount_cents).label('total')
    ).join(
        Expense, Expense.category_id == ExpenseCategory.id
    ).filter(
        Expense.user_email == current_user.email,
        Expense.expense_date >= start_date,
        Expense.expense_date <= end_date
    ).group_by(ExpenseCategory.name).all()
    
    # Calculate tax-deductible expenses
    deductible_expenses = db.query(func.sum(Expense.amount_cents)).join(
        ExpenseCategory
    ).filter(
        Expense.user_email == current_user.email,
        Expense.expense_date >= start_date,
        Expense.expense_date <= end_date,
        ExpenseCategory.name.in_([
            'Office Supplies', 'Professional Development', 'Software & Subscriptions',
            'Marketing & Advertising', 'Travel', 'Meals & Entertainment',
            'Home Office', 'Insurance', 'Professional Services'
        ])
    ).scalar() or 0
    
    # Get revenue from completed jobs
    revenue = db.query(func.sum(Job.quoted_amount)).filter(
        Job.user_id == current_user.id,
        Job.status == "completed",
        Job.end_date >= start_date
    ).scalar() or 0
    
    # Calculate profit
    profit = revenue - total_expenses
    
    # Simple tax estimate (25% effective rate on profit after deductions)
    taxable_income = max(0, profit - deductible_expenses)
    tax_estimate = int(taxable_income * 0.25)
    
    # Calculate cash runway (months of expenses covered)
    monthly_burn_rate = total_expenses
    if period == "quarter":
        monthly_burn_rate = total_expenses // 3
    elif period == "year":
        monthly_burn_rate = total_expenses // 12
    
    # DEMO DATA: Bank balance placeholder (TODO: integrate with Plaid for real balance)
    estimated_cash = 15000 * 100  # $15,000 in cents (DEMO)
    cash_runway_months = round(estimated_cash / monthly_burn_rate, 1) if monthly_burn_rate > 0 else 999
    
    return {
        "status": "success",
        # Removed is_demo_data to reflect real calculations where possible
        "period": period,
        "date_range": {
            "start": start_date.isoformat(),
            "end": end_date.isoformat()
        },
        "metrics": {
            "revenue": revenue / 100.0,
            "expenses": total_expenses / 100.0,
            "profit": profit / 100.0,
            "profit_margin": round((profit / revenue * 100) if revenue > 0 else 0, 1),
            "active_jobs": db.query(func.count(Job.id)).filter(Job.user_id == current_user.id, Job.status == "active").scalar() or 0,
            "tax_estimate": tax_estimate / 100.0,
            "deductible_expenses": deductible_expenses / 100.0,
            "cash_runway_months": cash_runway_months,
            "monthly_burn_rate": (monthly_burn_rate / 100.0) if monthly_burn_rate > 0 else 0
        },
        "expense_breakdown": [
            {
                "category": cat.name,
                "amount": cat.total / 100.0,
                "percentage": round((cat.total / total_expenses * 100) if total_expenses > 0 else 0, 1)
            }
            for cat in expense_breakdown
        ],
        "wellness_score": calculate_wellness_score(
            profit_margin=(profit / revenue * 100) if revenue > 0 else 0,
            cash_runway=cash_runway_months,
            tracking_consistency=calculate_tracking_consistency(db, current_user.id),
            deduction_rate=(deductible_expenses / total_expenses * 100) if total_expenses > 0 else 0
        )
    }

def calculate_wellness_score(profit_margin: float, cash_runway: float, 
                           tracking_consistency: float, deduction_rate: float) -> int:
    """Calculate financial wellness score (0-100)"""
    
    # Profit margin score (0-25 points)
    # 20%+ = 25 points, 10% = 15 points, 0% = 5 points, negative = 0
    if profit_margin >= 20:
        profit_score = 25
    elif profit_margin >= 10:
        profit_score = 15 + (profit_margin - 10) * 1
    elif profit_margin >= 0:
        profit_score = 5 + profit_margin * 1
    else:
        profit_score = 0
    
    # Cash runway score (0-25 points)
    # 6+ months = 25 points, 3 months = 15 points, 1 month = 5 points
    if cash_runway >= 6:
        runway_score = 25
    elif cash_runway >= 3:
        runway_score = 15 + (cash_runway - 3) * 3.33
    elif cash_runway >= 1:
        runway_score = 5 + (cash_runway - 1) * 5
    else:
        runway_score = cash_runway * 5
    
    # Tracking consistency score (0-25 points)
    tracking_score = tracking_consistency * 0.25
    
    # Deduction optimization score (0-25 points)
    # Finding 30%+ deductions = 25 points
    deduction_score = min(deduction_rate * 0.83, 25)
    
    total_score = int(profit_score + runway_score + tracking_score + deduction_score)
    return max(0, min(100, total_score))

@lru_cache(maxsize=64)
@dashboard_router.get("/insights")
async def get_insights(
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> Dict[str, Any]:
    """Get AI-powered financial insights based on user data"""
    
    now = datetime.utcnow()
    last_30_days = now - timedelta(days=30)
    last_90_days = now - timedelta(days=90)
    
    insights = []
    
    # 1. Spending Pattern Insights
    current_month_spending = db.query(func.sum(Expense.amount_cents)).filter(
        Expense.user_email == current_user.email,
        Expense.expense_date >= now.replace(day=1)
    ).scalar() or 0
    
    last_month_spending = db.query(func.sum(Expense.amount_cents)).filter(
        Expense.user_email == current_user.email,
        Expense.expense_date >= (now - timedelta(days=30)).replace(day=1),
        Expense.expense_date < now.replace(day=1)
    ).scalar() or 0
    
    if last_month_spending > 0:
        spending_change = ((current_month_spending - last_month_spending) / last_month_spending) * 100
        if spending_change > 20:
            insights.append({
                "type": "warning",
                "category": "spending",
                "title": "Spending Increase Alert",
                "message": f"Your spending is up {spending_change:.0f}% this month. Consider reviewing recent expenses.",
                "action": "Review expenses",
                "priority": "high"
            })
        elif spending_change < -20:
            insights.append({
                "type": "success",
                "category": "spending",
                "title": "Great Cost Control!",
                "message": f"You've reduced spending by {abs(spending_change):.0f}% this month. Keep it up!",
                "action": "View savings",
                "priority": "medium"
            })
    
    # 2. Category Anomaly Detection
    top_categories = db.query(
        ExpenseCategory.name,
        func.sum(Expense.amount_cents).label('total')
    ).join(
        Expense
    ).filter(
        Expense.user_email == current_user.email,
        Expense.expense_date >= last_30_days
    ).group_by(ExpenseCategory.name).order_by(func.sum(Expense.amount_cents).desc()).limit(3).all()
    
    for category in top_categories:
        # Check if any category is over 40% of total spending
        category_percentage = (category.total / current_month_spending * 100) if current_month_spending > 0 else 0
        if category_percentage > 40:
            insights.append({
                "type": "info",
                "category": "budget",
                "title": f"High {category.name} Spending",
                "message": f"{category.name} represents {category_percentage:.0f}% of your expenses. Consider if this aligns with your goals.",
                "action": "Set budget",
                "priority": "medium"
            })
    
    # 3. Tax Optimization Opportunities
    uncategorized_count = db.query(func.count(Expense.id)).filter(
        Expense.user_email == current_user.email,
        Expense.category_id.is_(None),
        Expense.expense_date >= last_30_days
    ).scalar() or 0
    
    if uncategorized_count > 5:
        insights.append({
            "type": "warning",
            "category": "tax",
            "title": "Missing Tax Deductions",
            "message": f"You have {uncategorized_count} uncategorized expenses. Categorizing them could reveal tax deductions.",
            "action": "Categorize now",
            "priority": "high"
        })
    
    # 4. Receipt Capture Reminder
    missing_receipts = db.query(func.count(Expense.id)).filter(
        Expense.user_email == current_user.email,
        Expense.receipt_url.is_(None),
        Expense.receipt_path.is_(None),
        Expense.amount_cents > 2500,  # $25+
        Expense.expense_date >= last_30_days
    ).scalar() or 0
    
    if missing_receipts > 0:
        insights.append({
            "type": "info",
            "category": "compliance",
            "title": "Receipt Capture Needed",
            "message": f"{missing_receipts} expenses over $25 are missing receipts. The IRS requires receipts for audit protection.",
            "action": "Upload receipts",
            "priority": "medium"
        })
    
    # 5. Cash Flow Insight
    weekly_average = current_month_spending / 4
    if weekly_average > 0:
        burn_rate_daily = weekly_average / 7 / 100  # Convert to dollars per day
        insights.append({
            "type": "info",
            "category": "cashflow",
            "title": "Daily Burn Rate",
            "message": f"You're spending an average of ${burn_rate_daily:.2f} per day. Track daily to stay on budget.",
            "action": "Set daily limit",
            "priority": "low"
        })
    
    # 6. Positive Reinforcement
    streak_days = calculate_tracking_streak(db, current_user.id)
    if streak_days >= 7:
        insights.append({
            "type": "success",
            "category": "habits",
            "title": f"{streak_days}-Day Tracking Streak!",
            "message": "Consistent tracking leads to 23% better financial outcomes. You're building great habits!",
            "action": "Keep going",
            "priority": "low"
        })
    
    return {
        "status": "success",
        "insights": sorted(insights, key=lambda x: {"high": 0, "medium": 1, "low": 2}[x["priority"]]),
        "summary": {
            "total_insights": len(insights),
            "high_priority": len([i for i in insights if i["priority"] == "high"]),
            "categories": list(set(i["category"] for i in insights))
        }
    }

def calculate_tracking_streak(db: Session, user_id: str) -> int:
    """Calculate consecutive days of expense tracking"""
    # Get dates with expenses in last 30 days
    expense_dates = db.query(
        func.date(Expense.expense_date).label('date')
    ).filter(
        Expense.user_email == user_email,
        Expense.expense_date >= datetime.utcnow() - timedelta(days=30)
    ).group_by(func.date(Expense.expense_date)).order_by(func.date(Expense.expense_date).desc()).all()
    
    if not expense_dates:
        return 0
    
    # Count consecutive days from today backwards
    streak = 0
    current_date = date.today()
    
    for exp_date in expense_dates:
        if exp_date.date == current_date:
            streak += 1
            current_date = current_date - timedelta(days=1)
        else:
            break
    
    return streak


@dashboard_router.get("/export")
async def export_dashboard_data(
    format: str = "csv",
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Export dashboard data for the current user.

    Currently supports CSV export of expenses with basic fields.
    """
    # Fetch user's expenses
    expenses = db.query(Expense).filter(Expense.user_email == current_user.email).order_by(Expense.expense_date.desc()).all()

    if format.lower() == "csv":
        output = io.StringIO()
        writer = csv.writer(output)
        writer.writerow(["Date", "Category", "Job", "Amount", "Vendor", "Description"])    
        for e in expenses:
            category_name = None
            try:
                # Lazy-load category name if relationship is configured
                category_name = e.category.name if getattr(e, "category", None) else None
            except Exception:
                category_name = None
            writer.writerow([
                getattr(e, "expense_date", None).isoformat() if getattr(e, "expense_date", None) else "",
                category_name or "",
                getattr(e, "job_name", "") or "",
                (e.amount_cents or 0) / 100.0,
                getattr(e, "vendor", "") or "",
                getattr(e, "description", "") or "",
            ])

        output.seek(0)
        return StreamingResponse(
            io.BytesIO(output.getvalue().encode("utf-8")),
            media_type="text/csv",
            headers={
                "Content-Disposition": "attachment; filename=dashboard_expenses.csv"
            },
        )

    # Future: support JSON export
    return {"status": "unsupported_format", "message": "Only CSV export is currently supported"}