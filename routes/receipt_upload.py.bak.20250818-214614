# Receipt Upload & OCR Routes
"""
Receipt Upload & OCR Processing Routes
Handles file uploads, OCR processing, and expense auto-population
"""

import os
import uuid
from datetime import datetime
from typing import List, Optional
from fastapi import APIRouter, Depends, HTTPException, UploadFile, File, Form
from sqlalchemy.orm import Session
from PIL import Image
import pytesseract
import re
from decimal import Decimal

from models.user import User
from models.expense import Expense
from dependencies.auth import get_current_user
from dependencies.database import get_db

router = APIRouter(prefix="/api/receipts", tags=["receipts"])

# OCR Configuration
ALLOWED_EXTENSIONS = {'.jpg', '.jpeg', '.png', '.pdf', '.tiff', '.bmp'}
MAX_FILE_SIZE = 10 * 1024 * 1024  # 10MB
UPLOAD_DIR = "uploads/receipts"

# Ensure upload directory exists
os.makedirs(UPLOAD_DIR, exist_ok=True)

def extract_amount_from_text(text: str) -> Optional[Decimal]:
    """Extract monetary amount from OCR text"""
    # Common patterns for amounts
    patterns = [
        r'\$?\s*(\d{1,3}(?:,\d{3})*(?:\.\d{2})?)',  # $1,234.56 or 1234.56
        r'TOTAL\s*\$?\s*(\d{1,3}(?:,\d{3})*(?:\.\d{2})?)',  # TOTAL $123.45
        r'AMOUNT\s*\$?\s*(\d{1,3}(?:,\d{3})*(?:\.\d{2})?)',  # AMOUNT $123.45
        r'DUE\s*\$?\s*(\d{1,3}(?:,\d{3})*(?:\.\d{2})?)',  # DUE $123.45
    ]
    
    for pattern in patterns:
        matches = re.findall(pattern, text, re.IGNORECASE)
        if matches:
            # Get the largest amount (usually the total)
            amounts = [Decimal(match.replace(',', '')) for match in matches]
            return max(amounts)
    
    return None

def extract_date_from_text(text: str) -> Optional[datetime]:
    """Extract date from OCR text"""
    # Common date patterns
    patterns = [
        r'(\d{1,2})[/-](\d{1,2})[/-](\d{2,4})',  # MM/DD/YYYY or MM-DD-YYYY
        r'(\d{4})[/-](\d{1,2})[/-](\d{1,2})',  # YYYY/MM/DD or YYYY-MM-DD
        r'(\w{3})\s+(\d{1,2}),?\s+(\d{4})',  # Jan 15, 2024
    ]
    
    for pattern in patterns:
        matches = re.findall(pattern, text, re.IGNORECASE)
        if matches:
            try:
                if len(matches[0]) == 3:
                    if len(matches[0][2]) == 4:  # Full year
                        if int(matches[0][0]) > 1000:  # YYYY format
                            year, month, day = matches[0]
                        else:  # MM/DD/YYYY format
                            month, day, year = matches[0]
                    else:  # MM/DD/YY format
                        month, day, year = matches[0]
                        year = f"20{year}" if int(year) < 50 else f"19{year}"
                    
                    return datetime(int(year), int(month), int(day))
            except (ValueError, IndexError):
                continue
    
    return None

def extract_merchant_from_text(text: str) -> Optional[str]:
    """Extract merchant name from OCR text"""
    # Common merchant patterns
    patterns = [
        r'^([A-Z\s&]+)\s*$',  # All caps merchant name
        r'([A-Z][A-Z\s&]+)\s*STORE',  # STORE suffix
        r'([A-Z][A-Z\s&]+)\s*INC',  # INC suffix
        r'([A-Z][A-Z\s&]+)\s*LLC',  # LLC suffix
        r'([A-Z][A-Z\s&]+)\s*CORP',  # CORP suffix
    ]
    
    lines = text.split('\n')
    for line in lines[:10]:  # Check first 10 lines
        line = line.strip()
        if len(line) > 3 and len(line) < 50:  # Reasonable merchant name length
            for pattern in patterns:
                match = re.search(pattern, line, re.IGNORECASE)
                if match:
                    merchant = match.group(1).strip()
                    if merchant and len(merchant) > 2:
                        return merchant
    
    return None

def categorize_expense(merchant: str, description: str) -> Optional[str]:
    """Auto-categorize expense based on merchant and description"""
    # Simple keyword-based categorization
    categories = {
        'food': ['restaurant', 'cafe', 'coffee', 'pizza', 'burger', 'subway', 'mcdonalds', 'starbucks'],
        'transportation': ['uber', 'lyft', 'taxi', 'gas', 'fuel', 'shell', 'exxon', 'chevron'],
        'office': ['staples', 'office depot', 'amazon', 'walmart', 'target'],
        'utilities': ['electric', 'water', 'gas', 'internet', 'phone', 'verizon', 'at&t'],
        'entertainment': ['netflix', 'spotify', 'movie', 'theater', 'concert'],
        'travel': ['hotel', 'airbnb', 'airline', 'delta', 'united', 'american'],
    }
    
    text = f"{merchant} {description}".lower()
    
    for category, keywords in categories.items():
        for keyword in keywords:
            if keyword in text:
                return category
    
    return 'other'

@router.post("/upload")
async def upload_receipt(
    file: UploadFile = File(...),
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Upload and process receipt image"""
    
    # Validate file
    if not file.filename:
        raise HTTPException(status_code=400, detail="No file provided")
    
    file_ext = os.path.splitext(file.filename)[1].lower()
    if file_ext not in ALLOWED_EXTENSIONS:
        raise HTTPException(
            status_code=400, 
            detail=f"File type not allowed. Allowed: {', '.join(ALLOWED_EXTENSIONS)}"
        )
    
    # Check file size
    file_content = await file.read()
    if len(file_content) > MAX_FILE_SIZE:
        raise HTTPException(status_code=400, detail="File too large. Max 10MB")
    
    # Generate unique filename
    filename = f"{uuid.uuid4()}{file_ext}"
    filepath = os.path.join(UPLOAD_DIR, filename)
    
    # Save file
    try:
        with open(filepath, "wb") as f:
            f.write(file_content)
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to save file: {str(e)}")
    
    # Process OCR
    try:
        # Open image with PIL
        image = Image.open(filepath)
        
        # Extract text using OCR
        text = pytesseract.image_to_string(image)
        
        # Extract information
        amount = extract_amount_from_text(text)
        date = extract_date_from_text(text)
        merchant = extract_merchant_from_text(text)
        
        # Auto-categorize
        category = categorize_expense(merchant or "", text[:200])
        
        # Create expense record
        expense_data = {
            "user_id": current_user.id,
            "amount": amount or Decimal('0.00'),
            "description": f"Receipt: {merchant or 'Unknown merchant'}",
            "date": date or datetime.now(),
            "category": category,
            "receipt_path": filepath,
            "ocr_text": text[:1000],  # Store first 1000 chars of OCR text
            "is_auto_generated": True
        }
        
        # Save to database
        expense = Expense(**expense_data)
        db.add(expense)
        db.commit()
        db.refresh(expense)
        
        return {
            "success": True,
            "expense_id": expense.id,
            "extracted_data": {
                "amount": str(amount) if amount else None,
                "date": date.isoformat() if date else None,
                "merchant": merchant,
                "category": category,
                "confidence": "medium"  # Placeholder for confidence scoring
            },
            "ocr_text_preview": text[:200] + "..." if len(text) > 200 else text
        }
        
    except Exception as e:
        # Clean up file on error
        if os.path.exists(filepath):
            os.remove(filepath)
        raise HTTPException(status_code=500, detail=f"OCR processing failed: {str(e)}")

@router.get("/extracted/{expense_id}")
async def get_extracted_data(
    expense_id: str,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Get extracted data for an expense"""
    
    expense = db.query(Expense).filter(
        Expense.id == expense_id,
        Expense.user_email == current_user.email
    ).first()
    
    if not expense:
        raise HTTPException(status_code=404, detail="Expense not found")
    
    return {
        "expense_id": expense.id,
        "amount": str(expense.amount),
        "description": expense.description,
        "date": expense.date.isoformat(),
        "category": expense.category,
        "receipt_path": expense.receipt_path,
        "ocr_text": expense.ocr_text,
        "is_auto_generated": expense.is_auto_generated
    }

@router.put("/update/{expense_id}")
async def update_extracted_expense(
    expense_id: str,
    amount: Optional[float] = Form(None),
    description: Optional[str] = Form(None),
    date: Optional[str] = Form(None),
    category: Optional[str] = Form(None),
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Update extracted expense data"""
    
    expense = db.query(Expense).filter(
        Expense.id == expense_id,
        Expense.user_email == current_user.email
    ).first()
    
    if not expense:
        raise HTTPException(status_code=404, detail="Expense not found")
    
    # Update fields
    if amount is not None:
        expense.amount = Decimal(str(amount))
    if description is not None:
        expense.description = description
    if date is not None:
        try:
            expense.date = datetime.fromisoformat(date)
        except ValueError:
            raise HTTPException(status_code=400, detail="Invalid date format")
    if category is not None:
        expense.category = category
    
    expense.is_auto_generated = False  # Mark as manually reviewed
    
    db.commit()
    db.refresh(expense)
    
    return {
        "success": True,
        "expense_id": expense.id,
        "message": "Expense updated successfully"
    }

@router.delete("/delete/{expense_id}")
async def delete_receipt_expense(
    expense_id: str,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Delete expense and associated receipt file"""
    
    expense = db.query(Expense).filter(
        Expense.id == expense_id,
        Expense.user_email == current_user.email
    ).first()
    
    if not expense:
        raise HTTPException(status_code=404, detail="Expense not found")
    
    # Delete receipt file
    if expense.receipt_path and os.path.exists(expense.receipt_path):
        try:
            os.remove(expense.receipt_path)
        except Exception as e:
            # Log error but continue with database deletion
            import logging
            logger = logging.getLogger(__name__)
            logger.error(f"Failed to delete receipt file: {e}")
    
    # Delete from database
    db.delete(expense)
    db.commit()
    
    return {
        "success": True,
        "message": "Expense and receipt deleted successfully"
    }

@router.get("/stats")
async def get_receipt_stats(
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Get receipt processing statistics"""
    
    # Get user's receipt expenses
    receipt_expenses = db.query(Expense).filter(
        Expense.user_email == current_user.email,
        Expense.receipt_path.isnot(None)
    ).all()
    
    total_receipts = len(receipt_expenses)
    auto_generated = len([e for e in receipt_expenses if e.is_auto_generated])
    manually_reviewed = total_receipts - auto_generated
    
    # Calculate total amount from receipts
    total_amount = sum(e.amount for e in receipt_expenses)
    
    # Category breakdown
    categories = {}
    for expense in receipt_expenses:
        cat = expense.category or 'uncategorized'
        categories[cat] = categories.get(cat, 0) + 1
    
    return {
        "total_receipts": total_receipts,
        "auto_generated": auto_generated,
        "manually_reviewed": manually_reviewed,
        "total_amount": str(total_amount),
        "category_breakdown": categories,
        "accuracy_rate": f"{(manually_reviewed/total_receipts*100):.1f}%" if total_receipts > 0 else "0%"
    } 